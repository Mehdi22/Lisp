# Project:	AI HW2 - eight puzzle
# Name:		Mengqi Zong
# Email:	mz2326@columbia.edu

1. How to run the program.

a) Compile the program
First, please compile queue.lisp. Then compile eight-puzzle.lisp.

b) Run by default config
The easiest way to run the program is typing (solve-puzzle). By default, 
intitial state is generated by randomly making 30 steps from goal state 
(0 1 2 3 4 5 6 7 8). And the default heuristic function is misplaced-titles.

c) Customized run

Here is the definition of function solve-puzzle:
(defun solve-puzzle (&optional (heurf #'misplaced-tiles)
		     (initial-state '(0 1 2 3 4 5 6 7 8)) (step 30))
		     ...)

Three heuristic functions are #'misplaced-tiles, #'manhattan-distance and 
#'linear-conflict. Typing (solve-puzzle #'manhattan-distance) will solve a
 random intial state using heuristic function #'manhattan-distance.

If you want use a specified initial state, for example (8 7 6 5 4 3 2 1 0).
Syntax is:
(solve-puzzle #'misplaced-tiles '(8 7 6 5 4 3 2 1 0) 0)

Be _CAREFUL_ about the last parameter 0. This means program will not 
randomnize the initial state (In another way, randomly moving the initial 
state by 0 step).

Also, the program does not have any error checking mechanism. In order to
get the right result, you have to make sure the input is correct.

2. Heuristic Function linear-conflict

Ref: slidingPuzzleHeuristicsCaoGause.ppt -- Internet

Here is the definition of linear conflict: Two tiles tj and tk are in a
linear conflict if tj and tk are in the same line, the goal positions of
tj and tk are both in that line, tj is to the right of tk and goal position
of tj is to the left of the goal position of tk.

Linear conflict adds at least two moves to the Manhattan distance of the two
conflict tiles, by forcing them to surround one another. And if tj and tk
are not linear conflict. The move are the same as Manhattan distance.
Therefore, the heuristic function will add a cost of 2 moves for each pair
of conflicting tiles. Then linear conflict dominates Manhattan distance.

Compared with Manhattan distance, linear conflict is more accurate and
more close to the real move style. But linear conflict is still a simplified
version of eight puzzle.

The linear conflict heuristic is monotone (and therefore admissible).

Proof:
Let current state be s, and its successor state be s'. Then we can prove
that f(s') >= f(s).  Since f(s) = g(s) + h(s), where g(s') = g(s) + 1 and
h(s) = MD(s) + LC(s).

In the movement from a state to its successor, let us assume that tile x
moves from row r(old) to r(new), while remaining in colum c(k). There
are three cases:

a) The goal position of x is ni neither r(old) nor r(new).
md(s',x) = md(s,x) +/- 1. LC does not change. Therefore, h(s') = h(s') +/- 1
and f(s') = f(s) + 1 +/- 1 >= f(s).

b) The goal position of x is in r(new). 
md(s',x) = md(s,x) - 1. lc(s') = lc(s) + 2 or lc(s') = lc(s). So
h(s') = h(s) +/- 1. f(s') = f(s) + 1 +/- 1 >= f(s)

c The goal position of x is in r(old).
md(s',x) = md(s,x) + 1. lc(s') = lc(s) - 2 or lc(s') = lc(s). So
h(s') = h(s) +/-1. f(s') = f(s) + 1 +/- 1 >= f(s).

In all cases, f(s') >= f(s). Similiaryly for movement within a row.

So, linear conflict heuristic is monotone and admissible.

3. Examples

a) Example 1

# a.1 misplaced-tiles 

CL-USER> (solve-puzzle)
Initial state: (2 8 5 1 0 7 3 6 4)
processing...
node: 1946
step: 14
((2 0 5 1 8 7 3 6 4) (0 2 5 1 8 7 3 6 4) (1 2 5 0 8 7 3 6 4)
 (1 2 5 3 8 7 0 6 4) (1 2 5 3 8 7 6 0 4) (1 2 5 3 8 7 6 4 0)
 (1 2 5 3 8 0 6 4 7) (1 2 5 3 0 8 6 4 7) (1 2 5 3 4 8 6 0 7)
 (1 2 5 3 4 8 6 7 0) (1 2 5 3 4 0 6 7 8) (1 2 0 3 4 5 6 7 8)
 (1 0 2 3 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

# a.2 manhattan-distance

CL-USER> (solve-puzzle #'manhattan-distance '(2 8 5 1 0 7 3 6 4) 0)
Initial state: (2 8 5 1 0 7 3 6 4)
processing...
node: 27
step: 14
((2 0 5 1 8 7 3 6 4) (0 2 5 1 8 7 3 6 4) (1 2 5 0 8 7 3 6 4)
 (1 2 5 3 8 7 0 6 4) (1 2 5 3 8 7 6 0 4) (1 2 5 3 8 7 6 4 0)
 (1 2 5 3 8 0 6 4 7) (1 2 5 3 0 8 6 4 7) (1 2 5 3 4 8 6 0 7)
 (1 2 5 3 4 8 6 7 0) (1 2 5 3 4 0 6 7 8) (1 2 0 3 4 5 6 7 8)
 (1 0 2 3 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

# a.3 linear-conflict

CL-USER> (solve-puzzle #'linear-conflict '(2 8 5 1 0 7 3 6 4) 0)
Initial state: (2 8 5 1 0 7 3 6 4)
processing...
node: 27
step: 14
((2 0 5 1 8 7 3 6 4) (0 2 5 1 8 7 3 6 4) (1 2 5 0 8 7 3 6 4)
 (1 2 5 3 8 7 0 6 4) (1 2 5 3 8 7 6 0 4) (1 2 5 3 8 7 6 4 0)
 (1 2 5 3 8 0 6 4 7) (1 2 5 3 0 8 6 4 7) (1 2 5 3 4 8 6 0 7)
 (1 2 5 3 4 8 6 7 0) (1 2 5 3 4 0 6 7 8) (1 2 0 3 4 5 6 7 8)
 (1 0 2 3 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

b) Example 2

# b.1 misplaced-tiles

CL-USER> (solve-puzzle)
Initial state: (6 4 3 1 2 5 7 8 0)
processing...
node: 17475
step: 16
((6 4 3 1 2 0 7 8 5) (6 4 3 1 0 2 7 8 5) (6 0 3 1 4 2 7 8 5)
 (6 3 0 1 4 2 7 8 5) (6 3 2 1 4 0 7 8 5) (6 3 2 1 4 5 7 8 0)
 (6 3 2 1 4 5 7 0 8) (6 3 2 1 0 5 7 4 8) (6 3 2 0 1 5 7 4 8)
 (0 3 2 6 1 5 7 4 8) (3 0 2 6 1 5 7 4 8) (3 1 2 6 0 5 7 4 8)
 (3 1 2 6 4 5 7 0 8) (3 1 2 6 4 5 0 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# b.2 manhattan-distance

CL-USER> (solve-puzzle #'manhattan-distance '(6 4 3 1 2 5 7 8 0) 0)
Initial state: (6 4 3 1 2 5 7 8 0)
processing...
node: 111
step: 16
((6 4 3 1 2 0 7 8 5) (6 4 3 1 0 2 7 8 5) (6 0 3 1 4 2 7 8 5)
 (6 3 0 1 4 2 7 8 5) (6 3 2 1 4 0 7 8 5) (6 3 2 1 0 4 7 8 5)
 (6 3 2 0 1 4 7 8 5) (0 3 2 6 1 4 7 8 5) (3 0 2 6 1 4 7 8 5)
 (3 1 2 6 0 4 7 8 5) (3 1 2 6 4 0 7 8 5) (3 1 2 6 4 5 7 8 0)
 (3 1 2 6 4 5 7 0 8) (3 1 2 6 4 5 0 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# b.3 linear-conflict

CL-USER> (solve-puzzle #'linear-conflict '(6 4 3 1 2 5 7 8 0) 0)
Initial state: (6 4 3 1 2 5 7 8 0)
processing...
node: 57
step: 16
((6 4 3 1 2 0 7 8 5) (6 4 3 1 0 2 7 8 5) (6 4 3 0 1 2 7 8 5)
 (0 4 3 6 1 2 7 8 5) (4 0 3 6 1 2 7 8 5) (4 3 0 6 1 2 7 8 5)
 (4 3 2 6 1 0 7 8 5) (4 3 2 6 1 5 7 8 0) (4 3 2 6 1 5 7 0 8)
 (4 3 2 6 1 5 0 7 8) (4 3 2 0 1 5 6 7 8) (0 3 2 4 1 5 6 7 8)
 (3 0 2 4 1 5 6 7 8) (3 1 2 4 0 5 6 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

c) Example 3

# c.1 misplaced-tiles

CL-USER> (solve-puzzle)
Initial state: (0 3 1 4 7 2 6 8 5)
processing...
node: 10
step: 8
((3 0 1 4 7 2 6 8 5) (3 1 0 4 7 2 6 8 5) (3 1 2 4 7 0 6 8 5)
 (3 1 2 4 7 5 6 8 0) (3 1 2 4 7 5 6 0 8) (3 1 2 4 0 5 6 7 8)
 (3 1 2 0 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

# c.2 manhattan-distance

CL-USER> (solve-puzzle #'manhattan-distance '(0 3 1 4 7 2 6 8 5) 0)
Initial state: (0 3 1 4 7 2 6 8 5)
processing...
node: 8
step: 8
((3 0 1 4 7 2 6 8 5) (3 1 0 4 7 2 6 8 5) (3 1 2 4 7 0 6 8 5)
 (3 1 2 4 7 5 6 8 0) (3 1 2 4 7 5 6 0 8) (3 1 2 4 0 5 6 7 8)
 (3 1 2 0 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

# c.3 linear-conflict

CL-USER> (solve-puzzle #'linear-conflict '(0 3 1 4 7 2 6 8 5) 0)
Initial state: (0 3 1 4 7 2 6 8 5)
processing...
node: 8
step: 8
((3 0 1 4 7 2 6 8 5) (3 1 0 4 7 2 6 8 5) (3 1 2 4 7 0 6 8 5)
 (3 1 2 4 7 5 6 8 0) (3 1 2 4 7 5 6 0 8) (3 1 2 4 0 5 6 7 8)
 (3 1 2 0 4 5 6 7 8) (0 1 2 3 4 5 6 7 8))

d) Example 4

# d.1 misplaced-tiles

CL-USER> (solve-puzzle)
Initial state: (4 3 0 5 2 1 6 7 8)
processing...
node: 156
step: 10
((4 3 1 5 2 0 6 7 8) (4 3 1 5 0 2 6 7 8) (4 3 1 0 5 2 6 7 8)
 (0 3 1 4 5 2 6 7 8) (3 0 1 4 5 2 6 7 8) (3 1 0 4 5 2 6 7 8)
 (3 1 2 4 5 0 6 7 8) (3 1 2 4 0 5 6 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# d.2 manhattan-distance

CL-USER> (solve-puzzle #'manhattan-distance '(4 3 0 5 2 1 6 7 8) 0)
Initial state: (4 3 0 5 2 1 6 7 8)
processing...
node: 10
step: 10
((4 3 1 5 2 0 6 7 8) (4 3 1 5 0 2 6 7 8) (4 3 1 0 5 2 6 7 8)
 (0 3 1 4 5 2 6 7 8) (3 0 1 4 5 2 6 7 8) (3 1 0 4 5 2 6 7 8)
 (3 1 2 4 5 0 6 7 8) (3 1 2 4 0 5 6 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# d.3 linear-conflict

CL-USER> (solve-puzzle #'linear-conflict '(4 3 0 5 2 1 6 7 8) 0)
Initial state: (4 3 0 5 2 1 6 7 8)
processing...
node: 10
step: 10
((4 3 1 5 2 0 6 7 8) (4 3 1 5 0 2 6 7 8) (4 3 1 0 5 2 6 7 8)
 (0 3 1 4 5 2 6 7 8) (3 0 1 4 5 2 6 7 8) (3 1 0 4 5 2 6 7 8)
 (3 1 2 4 5 0 6 7 8) (3 1 2 4 0 5 6 7 8) (3 1 2 0 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

e) Example 5

# e.1 misplaced-tiles

CL-USER> (solve-puzzle)
Initial state: (1 5 4 3 0 8 6 2 7)
processing...
node: 145
step: 10
((1 5 4 3 2 8 6 0 7) (1 5 4 3 2 8 6 7 0) (1 5 4 3 2 0 6 7 8)
 (1 5 4 3 0 2 6 7 8) (1 0 4 3 5 2 6 7 8) (1 4 0 3 5 2 6 7 8)
 (1 4 2 3 5 0 6 7 8) (1 4 2 3 0 5 6 7 8) (1 0 2 3 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# e.2 manhattan-distance

CL-USER> (solve-puzzle #'manhattan-distance '(1 5 4 3 0 8 6 2 7) 0)
Initial state: (1 5 4 3 0 8 6 2 7)
processing...
node: 10
step: 10
((1 5 4 3 2 8 6 0 7) (1 5 4 3 2 8 6 7 0) (1 5 4 3 2 0 6 7 8)
 (1 5 4 3 0 2 6 7 8) (1 0 4 3 5 2 6 7 8) (1 4 0 3 5 2 6 7 8)
 (1 4 2 3 5 0 6 7 8) (1 4 2 3 0 5 6 7 8) (1 0 2 3 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

# e.3 linear-conflict

CL-USER> (solve-puzzle #'linear-conflict '(1 5 4 3 0 8 6 2 7) 0)
Initial state: (1 5 4 3 0 8 6 2 7)
processing...
node: 10
step: 10
((1 5 4 3 2 8 6 0 7) (1 5 4 3 2 8 6 7 0) (1 5 4 3 2 0 6 7 8)
 (1 5 4 3 0 2 6 7 8) (1 0 4 3 5 2 6 7 8) (1 4 0 3 5 2 6 7 8)
 (1 4 2 3 5 0 6 7 8) (1 4 2 3 0 5 6 7 8) (1 0 2 3 4 5 6 7 8)
 (0 1 2 3 4 5 6 7 8))

f) Result Analysis

Based on the five examples above, we can see that linear-conflict generates
the least nodes to get the optimal solution, and misplaced-tiles generates
the most nodes to get the same optimal solution. Since, linear conflict
dominates Manhattan distace, which dominates misplaced tiles, we can say
that the more accurate the heuristic function is, the less nodes it needs to
generates to get the optimal solution.